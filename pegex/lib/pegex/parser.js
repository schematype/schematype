// Generated by CoffeeScript 2.3.1
(function() {
  require('../pegex/input');

  require('../pegex/optimizer');

  Pegex.Parser = class Parser {
    constructor({grammar, receiver, debug}) {
      var ref1;
      this.grammar = grammar;
      this.receiver = receiver;
      this.debug = debug;
      (this.grammar != null) || (function() {
        throw "Pegex.Parser object requires a grammar attribute";
      })();
      this.input = null;
      if (this.debug == null) {
        this.debug = (ref1 = (typeof process !== "undefined" && process !== null ? process.env.PEGEX_DEBUG : void 0) || Pegex.Parser.Debug) != null ? ref1 : false;
      }
      if (this.throw_on_error == null) {
        this.throw_on_error = true;
      }
    }

    // @debug=on
    parse(input, start) {
      var base, match, optimizer, start_rule_ref;
      if (start) {
        start = start.replace(/-/g, '_');
      }
      this.position = 0;
      this.farthest = 0;
      this.input = typeof input === 'string' ? new Pegex.Input({
        string: input
      }) : input;
      if (!this.input._is_open) {
        this.input.open();
      }
      this.buffer = this.input.read();
      if (!this.grammar) {
        throw "No 'grammar'. Can't parse";
      }
      (base = this.grammar).tree || (base.tree = this.grammar.make_tree());
      start_rule_ref = start || (this.grammar.tree['+toprule'] != null) && this.grammar.tree['+toprule'] || this.grammar.tree.TOP && 'TOP' || (function() {
        throw "No starting rule for Pegex.Parser.parse";
      })();
      if (this.receiver == null) {
        throw "No 'receiver'. Can't parse";
      }
      optimizer = new Pegex.Optimizer({
        parser: this,
        grammar: this.grammar,
        receiver: this.receiver
      });
      optimizer.optimize_grammar(start_rule_ref);
      // Add circular ref.
      this.receiver.parser = this;
      if (this.receiver.initial != null) {
        this.rule = start_rule_ref;
        this.parent = {};
        this.receiver.initial();
      }
      // TODO Make start_method in optimizer?
      if (this.debug) {
        match = optimizer.make_trace_wrapper(this.match_ref).call(this, start_rule_ref, {
          '+asr': false
        });
      } else {
        match = this.match_ref(start_rule_ref, {});
      }
      this.input.close();
      if (!match || this.position < this.buffer.length) {
        this.throw_error("Parse document failed for some reason");
        return;
      }
      if (this.receiver.final) {
        this.rule = start_rule_ref;
        this.parent = {};
        match = [this.receiver.final(...match)];
      }
      return match[0];
    }

    match_next(next) {
      var _match, assertion, count, i, kind, len1, m, match, max, method, min, position, result, return_, rule;
      // XXX say "match_next #{next}"
      ({rule, method, kind} = next);
      min = next['+min'];
      max = next['+max'];
      assertion = next['+asr'];
      position = this.position;
      match = [];
      count = 0;
      while (return_ = method.call(this, rule, next)) {
        if (!assertion) {
          position = this.position;
        }
        count++;
        match.push(...return_);
        if (max === 1) {
          break;
        }
      }
      if (!count && min === 0 && kind === 'all') {
        match = [[]];
      }
      if (max !== 1) {
        if (next['-flat']) {
          _match = [];
          for (i = 0, len1 = match.length; i < len1; i++) {
            m = match[i];
            if (m instanceof Array) {
              _match.push(...m);
            } else {
              _match.push(m);
            }
          }
          match = _match;
        } else {
          match = [match];
        }
      }
      result = count >= min && (!max || count <= max);
      result ^= assertion === -1;
      if (!result || assertion) {
        if ((this.position = position) > this.farthest) {
          this.farthest = position;
        }
      }
      if (!result) {
        return 0;
      }
      if (next['-skip']) {
        return [];
      } else {
        return match;
      }
    }

    match_rule(position, match = []) {
      var parent, ref, ret, rule;
      if ((this.position = position) > this.farthest) {
        this.farthest = position;
      }
      if (match.length > 1) {
        match = [match];
      }
      ({ref, parent} = this);
      rule = this.grammar.tree[ref] || (function() {
        throw `No rule defined for '${ref}'`;
      })();
      ret = rule.action.call(this.receiver, ...match);
      if (ret === void 0) {
        return [];
      } else {
        return [ret];
      }
    }

    match_ref(ref, parent) {
      var match, ret, rule;
      // XXX say "match_ref #{ref}"
      this.ref1 = ref;
      rule = this.grammar.tree[ref] || (function() {
        throw `No rule defined for '${ref}'`;
      })();
      match = this.match_next(rule);
      if (!match) {
        return;
      }
      if (rule.action == null) {
        return [];
      }
      this.rule = ref;
      this.parent = parent;
      ret = rule.action.call(this.receiver, ...match);
      if (ret === void 0) {
        return [];
      } else {
        return [ret];
      }
    }

    match_rgx(regexp) {
      var captures, i, m, num, re, ref1;
      // XXX say "match_rgx #{@ref1} #{regexp} '#{@buffer.substr(@position)}'"
      re = new RegExp(`^${regexp}`, 'g');
      m = re.exec(this.buffer.substr(this.position));
      if (m == null) {
        return;
      }
      this.position += re.lastIndex;
      if (this.position > this.farthest) {
        this.farthest = this.position;
      }
      captures = [];
      for (num = i = 1, ref1 = m.length; (1 <= ref1 ? i < ref1 : i > ref1); num = 1 <= ref1 ? ++i : --i) {
        captures.push(m[num] || '');
      }
      if (m.length > 2) {
        captures = [captures];
      }
      return captures;
    }

    match_all(list) {
      var elem, i, len, len1, match, position, set;
      position = this.position;
      set = [];
      len = 0;
      for (i = 0, len1 = list.length; i < len1; i++) {
        elem = list[i];
        if (match = this.match_next(elem)) {
          if (!(elem['+asr'] || elem['-skip'])) {
            set.push(...match);
            len++;
          }
        } else {
          if ((this.position = position) > this.farthest) {
            this.farthest = position;
          }
          return;
        }
      }
      if (len > 1) {
        set = [set];
      }
      return set;
    }

    match_any(list) {
      var elem, i, len1, match;
      for (i = 0, len1 = list.length; i < len1; i++) {
        elem = list[i];
        if (match = this.match_next(elem)) {
          return match;
        }
      }
      return null;
    }

    match_err(error) {
      return this.throw_error(error);
    }

    match_code(code) {
      var method;
      method = `match_rule_${code}`;
      return method.call(this);
    }

    trace(action) {
      var i, i1, i2, indent, j, ref1, ref2, snippet, x;
      indent = action.match(/^try_/);
      this.indent || (this.indent = 1);
      if (!indent) {
        this.indent--;
      }
      i1 = i2 = '';
      for (x = i = 0, ref1 = this.indent; (0 <= ref1 ? i <= ref1 : i >= ref1); x = 0 <= ref1 ? ++i : --i) {
        i1 += ' ';
      }
      for (x = j = 1, ref2 = 30 - action.length; (1 <= ref2 ? j <= ref2 : j >= ref2); x = 1 <= ref2 ? ++j : --j) {
        i2 += ' ';
      }
      if (indent) {
        this.indent++;
      }
      snippet = this.buffer.substr(this.position);
      if (snippet.length > 30) {
        snippet = snippet.substr(0, 30);
      }
      snippet = snippet.replace(/\n/g, '\\n');
      return console.warn(`${i1} ${action}${i2}>${snippet}<`);
    }

    throw_error(msg) {
      this.format_error(msg);
      if (!this.throw_on_error) {
        return 0;
      }
      throw this.error;
    }

    format_error(msg) {
      var column, context, line, lines, position;
      position = this.farthest;
      lines = (this.buffer.substr(0, position)).match(/\n/g);
      line = lines != null ? lines.length + 1 : 1;
      column = position - this.buffer.lastIndexOf("\n", position);
      context = this.buffer.substr(position, 50);
      context = context.replace(/\n/g, '\\n');
      return this.error = `Error parsing Pegex document:\n  msg: ${msg}\n  line: ${line}\n  column: ${column}\n  context: ${context}\n  position: ${position}`;
    }

  };

}).call(this);
