// Generated by CoffeeScript 2.3.1
(function() {
  Pegex.Optimizer = class Optimizer {
    constructor({
        parser: parser1,
        grammar,
        receiver
      }) {
      this.parser = parser1;
      this.grammar = grammar;
      this.receiver = receiver;
      (this.parser != null) || (function() {
        throw "Missing attribute 'parser' for Pegex.Optimizer";
      })();
      (this.grammar != null) || (function() {
        throw "Missing attribute 'grammar' for Pegex.Optimizer";
      })();
      (this.receiver != null) || (function() {
        throw "Missing attribute 'receiver' for Pegex.Optimizer";
      })();
    }

    optimize_grammar(start) {
      var extra, key, name, node, tree, val;
      tree = this.grammar.tree;
      if (tree['+optimized']) {
        return;
      }
      if (this.parser.maxparse != null) {
        this.set_max_parse;
      }
      this.extra = {};
      for (name in tree) {
        node = tree[name];
        if (typeof node === 'string') {
          continue;
        }
        this.optimize_node(node);
      }
      this.optimize_node({
        '.ref': start
      });
      extra = delete this.extra;
      for (key in extra) {
        val = extra[key];
        tree[key] = val;
      }
      return tree['+optimized'] = 1;
    }

    optimize_node(node) {
      var action, gotrule, i, j, kind, len, len1, max, method, min, n, ref, ref1, ref2, results, rule;
      min = node['+min'];
      max = node['+max'];
      if (node['+min'] == null) {
        node['+min'] = max != null ? 0 : 1;
      }
      if (node['+max'] == null) {
        node['+max'] = min != null ? 0 : 1;
      }
      if (node['+asr'] == null) {
        node['+asr'] = 0;
      }
      ref1 = ['ref', 'rgx', 'all', 'any', 'err', 'code', 'xxx'];
      for (i = 0, len = ref1.length; i < len; i++) {
        kind = ref1[i];
        if (kind === 'xxx') {
          return;
        }
        if (node.rule = node[`.${kind}`]) {
          delete node[`.${kind}`];
          node.kind = kind;
          if (kind === 'ref') {
            rule = node.rule || (function() {
              throw "";
            })();
            if ((method = this.grammar[`rule_${rule}`]) != null) {
              node.method = this.make_method_wrapper(method);
            } else if (this.grammar.tree[rule] == null) {
              if (method = this.grammar[rule] != null) {
                console.warn(`Warning:\n\n  You have a method called '${rule}' in your grammar.\n  It should probably be called 'rule_${rule}'.\n`);
              }
              throw `No rule '${rule}' defined in grammar`;
            }
          }
          if (node.method == null) {
            node.method = this.parser[`match_${kind}`] || (function() {
              throw "";
            })();
          }
          break;
        }
      }
      if (node.kind.match(/^(?:all|any)$/)) {
        ref2 = node.rule;
        results = [];
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          n = ref2[j];
          results.push(this.optimize_node(n));
        }
        return results;
      } else if (node.kind === 'ref') {
        ref = node.rule;
        rule = this.grammar.tree[ref];
        rule || (rule = this.extra[ref] = {});
        if (action = this.receiver[`got_${ref}`]) {
          rule.action = action;
        } else if (gotrule = this.receiver.gotrule) {
          rule.action = gotrule;
        }
        if (this.parser.debug) {
          return node.method = this.make_trace_wrapper(node.method);
        }
      } else if (node.kind === 'rgx') {
        // TODO Add ^ and compile re here
        return 0;
      }
    }

    // xxx node
    make_method_wrapper(method) {
      return function(ref, parent) {
        var parser;
        parser = this;
        parser.rule = ref;
        parser.parent = parent;
        return method.call(parser.grammar, parser, parser.buffer, parser.position);
      };
    }

    make_trace_wrapper(method) {
      return function(ref, parent) {
        var asr, note, result;
        asr = parent['+asr'];
        note = asr === -1 ? '(!)' : asr === 1 ? '(=)' : '';
        this.trace(`try_${ref}${note}`);
        if (result = method.call(this, ref, parent)) {
          this.trace(`got_${ref}${note}`);
        } else {
          this.trace(`not_${ref}${note}`);
        }
        return result;
      };
    }

    set_max_parse() {
      var counter, maxparse, method;
      require('../pegex/parser');
      maxparse = this.parser.maxparse;
      method = Pegex.Parser.match_ref;
      counter = 0;
      return Pegex.Parser.match_ref = function(...args) {
        if (counter++ >= maxparse) {
          throw `Maximum parsing rules reached (${maxparse})\n`;
        }
        return method.apply(this, ...args);
      };
    }

  };

}).call(this);
