// Generated by CoffeeScript 2.3.1
(function() {
  require('../pegex/parser');

  require('../pegex/pegex/grammar');

  require('../pegex/pegex/ast');

  require('../pegex/grammar/atoms');

  Pegex.Compiler = class Compiler {
    constructor() {
      this.tree = null;
      this._tree = null;
    }

    compile(input) {
      this.parse(input);
      this.combinate();
      this.native();
      return this;
    }

    parse(input) {
      var parser;
      parser = new Pegex.Parser({
        grammar: new Pegex.Pegex.Grammar,
        receiver: new Pegex.Pegex.AST
      });
      this.tree = parser.parse(input);
      return this;
    }

    combinate(rule) {
      var k, ref, v;
      if (rule == null) {
        rule = this.tree['+toprule'];
      }
      if (!rule) {
        return this;
      }
      this._tree = {};
      ref = this.tree;
      for (k in ref) {
        v = ref[k];
        if (k.match(/^\+/)) {
          this._tree[k] = v;
        }
      }
      this.combinate_rule(rule);
      this.tree = this._tree;
      delete this._tree;
      return this;
    }

    combinate_rule(rule) {
      var object;
      if (this._tree[rule] != null) {
        return;
      }
      object = this._tree[rule] = this.tree[rule];
      return this.combinate_object(object);
    }

    combinate_object(object) {
      var elem, i, j, len, len1, ref, ref1, regex, rule;
      if (object['.sep'] != null) {
        this.combinate_object(object['.sep']);
      }
      if (object['.rgx']) {
        this.combinate_re(object);
      } else if (object['.ref'] != null) {
        rule = object['.ref'];
        if (this.tree[rule] != null) {
          this.combinate_rule(rule);
        } else {
          if (regex = Pegex.Grammar.Atoms.prototype.atoms()[rule]) {
            this.tree[rule] = {
              '.rgx': regex
            };
            this.combinate_rule(rule);
          }
        }
      } else if (object['.any'] != null) {
        ref = object['.any'];
        for (i = 0, len = ref.length; i < len; i++) {
          elem = ref[i];
          this.combinate_object(elem);
        }
      } else if (object['.all'] != null) {
        ref1 = object['.all'];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          elem = ref1[j];
          this.combinate_object(elem);
        }
      } else if (object['.err']) {
        1;
      } else {
        throw `Can't combinate: ${object}`;
      }
      return this;
    }

    combinate_re(regexp) {
      var atoms, re, results;
      atoms = Pegex.Grammar.Atoms.prototype.atoms();
      re = regexp['.rgx'];
      results = [];
      while (true) {
        re = re.replace(/<([-\w]+)>/, (m, $1) => {
          var key;
          key = $1.replace(/-/g, '_');
          if (this.tree[key] != null) {
            if (this.tree[key]['.rgx'] != null) {
              return this.tree[key]['.rgx'];
            } else if (this.tree[key]['.ref'] != null) {
              return `<${this.tree[key]['.ref']}>`;
            } else {
              throw `'${key}' not defined as a single RE`;
            }
          } else if (atoms[key] != null) {
            return atoms[key];
          } else {
            throw `'${$1}' not defined in the grammar`;
          }
        });
        if (re === regexp['.rgx']) {
          break;
        }
        results.push(regexp['.rgx'] = re);
      }
      return results;
    }

    native() {
      return this;
    }

    js_regexes(node) {
      var elem, i, key, len, re, results, results1, value;
      if (typeof node === 'object') {
        if (node instanceof Array) {
          results = [];
          for (i = 0, len = node.length; i < len; i++) {
            elem = node[i];
            results.push(this.js_regexes(elem));
          }
          return results;
        } else {
          if (node['.rgx'] != null) {
            re = node['.rgx'];
            return node['.rgx'] = new RegExp(`^${re}`);
          } else {
            results1 = [];
            for (key in node) {
              value = node[key];
              results1.push(this.js_regexes(value));
            }
            return results1;
          }
        }
      }
    }

    to_yaml() {
      throw "Pegex.Compiler.to_yaml not yet defined";
    }

    to_json() {
      return JSON.stringify(this.tree);
    }

    to_js() {
      return (require('util')).format(this.tree);
    }

  };

  // vim: sw=2:

}).call(this);
